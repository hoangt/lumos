.. Lumos documentation master file, created by
   sphinx-quickstart on Thu Feb 14 10:20:41 2013.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

=================
 Lumos Framework
=================

.. toctree::
   :maxdepth: 2

Introduction
============

Lumos is a framework to analytically quantify the performance limits
of many-core, heterogeneous systems operating at low supply voltage
(e.g. near-threshold). Due to limited scaling of supply voltage, power
density is expected to grow in future technology nodes. This
increasing power density potentially limits the number of transistors
switching at full speed in the future. Near-threshold operation can
increase the number of simultaneously active cores, at the expense of
much lower operating frequency ("dim silicon"). Although promising
to increase overall throughput, dim cores suffer from diminishing
returns as the number of cores increases. At this point, hardware
accelerators become more efficient alternatives. Lumos is developed to
explore such a broad design space.

How to Get it
=============

Lumos is at its v0.1, which can be downloaded from `tar.gz
<https://github.com/liangwang/lumos/archive/v0.1.tar.gz>` or `zip
<https://github.com/liangwang/lumos/archive/v0.1.zip>`, or just check it
immediately at `here <https://github.com/liangwang/lumos/tree/v0.1>`. You can
always get the latest code of Lumos at `github <https://github.com/liangwang/lumos>`.

Quick Start
===========

Lumos is written in Python, so you definitely need a `python
<http://www.python.org>`_ installation to run it. Before starting to use the Lumos
framework, make sure you have meet the requirement for extra python
packages:

* numpy and scipy

  This is usually included in a typical installation of python. In
  case you do not have it, these two packages can be found at `numpy
  <http://www.numpy.org>`_ and `scipy <http://www.scipy.org>`_. Lumos
  has been tested on numpy-1.6.1 and scipy-0.9.0

* matplotlib

  This package is required to generate plots for analyses. It is
  usually included in the package repositories of popular Linux
  distributions (e.g. Ubuntu). Otherwise, you can always get it from
  `matplotlib <http://matplotlib.org>`_. Lumos has been tested on
  matplotlib-1.1.1rc.

* mpltools

  This package makes the plot generated by matplotlib more modernized.
  It can be obtained from `mpltools
  <https://github.com/tonysyu/mpltools>`_.

* lxml

  This package is required to parse the descriptions of kernels and
  workloads stored in xml files. It is included in the package
  repository of Ubuntu, and can also be downloaded at `lxml
  <http://lxml.de/index.html#download>`_. Lumos has been tested on
  lxml-2.3.2.

Now it is ready to go. Since it is purely pythonic, Lumos does not
need any compilation steps (technically speaking, the interpreter will
"compile" all python scripts to accelerate execution, but this is all
transparent to users). Just follow these steps:

1. Get the tarball, and unpack the package::

   >tar zxvf Lumos-0.1.tar.gz

2. Set environment variable ``LUMOS_HOME`` to root directory of the
   package::

   >cd Lumos-0.1
   >export LUMOS_HOME=(full-path-to)/Lumos-0.1

3. Run the sample analysis::

   >python lumos/analyses/core.py

4. Done!

Now the plots for this sample analysis should be ready to check out in
``$LUMOS_HOME/analyses/core/figures``.

Analysis
========

A typical analysis in the Lumos framework involves with three steps:
define the worload, define the system, do analysis.

Define Workload
---------------

.. highlight:: xml

The workload in the Lumos framework is defined as a pool of
applications. Each single application is divided into serial and
parallel parts, and the ratio is specified as ``f_parallel``. Part
of an application can be also partitioned into several computing
kernels. These kernels can be accelerated by various computing
units, such as multicore, possibly dim CPU cores, RL, and
customized ASIC. We model the speedup and the power consumption of
RL and customized ASIC for a given kernel by u-core parameters.

A workload is defined by enumerate all applications in the format
of XML, such as::

       <workload>
          <app name="app0">
            <f_parallel>1</f_parallel>
            <kernel_config>
              <kernel name="ker005" cov="0.4826"/>
            </kernel_config>
          </app>
          ...
       </workload>

where ``f_parallel`` is the parallel ratio. Within
``kernel_config``, the ``name`` is the name of the kernel, and
``cov`` is the coverage in percentage of the corresponding kernel.

A set of kernels is enumerated in the format of XML as well, such
as::

       <kernels>
         <kernel name="ker005">
	   <fpga miu="20"/>
	   <asic miu="100"/>
	   <occur>0.003206</occur>
	 </kernel>
	 ...
       </kernels>

Where ``miu`` is the relative performance for FPGA and ASIC,
respectively. ``occur`` is the probability of this kernel to be
presented in an application.

There are a couple of helper functions to assist you generating
kernels, applications following certain statistical distributions. See
:func:`~lumos.model.kernel.create_fixednorm_xml`,
:func:`~lumos.model.kernel.create_randnorm_xml`,
:func:`~lumos.model.workload.build`,
:func:`~lumos.model.workload.build_fixedcov` for more details.
Moreover, existing XML descriptions for kernels and workload can be
loaded by :func:`~lumos.model.kernel.load_xml` and
:func:`~lumos.model.workload.load_xml`, respectively.

Define System
-------------

Lumos supports conventional cores such as a Niagara2-like in-order core and an
out-or-order core (:class:`~lumos.model.core.IOCore` and
:class:`~lumos.model.core.O3Core`), as well as un-conventional cores, such as
accelerators (:class:`~lumos.model.ucore.UCore`), federated cores
(:class:`~lumos.model.fedcore.FedCore`).

On top of these cores, Lumos supports two kinds of systems: a homogeneous
multi-core system (:class:`~lumos.model.system.HomoSys`), and a heterogeneous
multi-core system with a serial core and certain amount of throughput cores, as
well as accelerators (:class:`~lumos.model.system.HeteroSys`). The usage of
these two systems are demonstrated later in Example Analysis section.


Do Analysis
-----------

:class:`~lumos.model.system.HeteroSys` provides a method
:func:`~lumos.model.system.HeteroSys.get_perf` to get the relative
performance of the system for a given application.

:class:`~lumos.model.system.HomoSys` provides a couple of methods to retrieve
relative performance of system for a given application:

* Explicit constrain on the supply voltage.

  In this case, the system will try to enable as many cores at the given supply
  as possible within the given power budget. If the supply voltage is relatively
  high, it ends up with a dark silicon homogeneous many-core system. Use
  :func:`~lumos.model.system.HomoSys.perf_by_vfs` and
  :func:`~lumos.model.system.HomoSys.perf_by_vdd` for this scenario.

* Explicit constrain on the number of active cores.

  In this case, the system will probe for the highest supply voltage for the
  core to meet the overall power budget. Use
  :func:`~lumos.model.system.HomoSys.perf_by_cnum` for this scenario.

* No constraints on the supply voltage or the number of active cores,

  In this case, the system will probe for the optimal configuration of supply
  voltage and the number of cores to achieve the best overall throughput. Use
  :func:`~lumos.model.system.HomoSys.opt_core_num` for this scenario.


Example Analyses
----------------

.. highlight:: python

1. Example of using :class:`~lumos.model.system.HomoSys`

   An example analysis of :class:`~lumos.model.system.HomoSys` is in
   ``$LUMOS_HOME/lumos/analyses/homosys_example.py``. This example models a
   homogeneous many-core architecture composed of Niagara2-like in-order cores.
   The system is defined as follow::

       sys = HomoSys()
       sys.set_sys_prop(area=self.sys_area, power=self.sys_power)
       sys.set_sys_prop(core=IOCore(mech=self.mech))


   The analysis compares four scenarios applied to the system: 1) dim cores
   without consideration of variation-induced frequency penalty; 2) dim
   cores considering the frequency penalty; 3) dim cores with reduced
   frequency penalty of 0.5 and 0.1 respectively; 4) dark cores with maximum
   supply voltage (1.3x nominal) and frequency. Each scenario will require some
   tweaks to system parameters, for example, the second scenario requires::

       sys.set_core_prop(tech=ctech, pv=True)


   More details can be found in
   :func:`~lumos.analyses.homosys_example.HomosysExample.analyze`. For each
   scenario, the relative performance is obtained by
   :func:`~lumos.model.system.HomoSys.opt_core_num` as follow::

       ret = sys.opt_core_num()
       ret['perf']


   Finally, :func:`~lumos.analyses.analysis.plot_series` is used to generate
   plot for the above scenarios, as in
   :func:`~lumos.analyses.homosys_example.HomosysExample.plot`.


2. Example of using :class:`~lumos.model.system.HeteroSys`

   An example analysis of :class:`~lumos.model.system.HeteroSys` is in
   ``$LUMOS_HOME/lumos/analyses/heterosys_example.py``. This example models a
   heterogeneous many-core system composed of in-order cores, reconfigurable
   logic (FPGA), and dedicated ASICs. All related files for this analysis are
   placed in ``$LUMOS_HOME/analyses/heterosys_example``. For maximum flexibility,
   this example employ an external configuration file to specify various input
   parameters in addition to command line parameters. The default configurations
   file is ``heterosys_example.cfg``. This example use pre-defined synthetic
   kernels and workloads stored in ``kernels_asicfpgaratio10x.xml`` and
   ``workload_norm40x10.xml``. The analysis will load kernels and workload as
   follow::

       kernels = kernel.load_xml(options.kernel)
       workload = workload.load_xml(options.workload)

   The system is defined as follow::

       sys = HeteroSys(self.budget)
       sys.set_mech('HKMGS')
       sys.set_tech(16)
       if kfirst != 0:  # there are ASIC accelerators to be added
           sys.set_asic('_gen_fixednorm_004', alloc*kfirst*0.33)
           sys.set_asic('_gen_fixednorm_005', alloc*kfirst*0.33)
           sys.set_asic('_gen_fixednorm_006', alloc*kfirst*0.34)
       sys.realloc_gpacc(alloc*(1-kfirst))
       sys.use_gpacc = True

   The performance is collected as follow::

       perfs = numpy.array([ sys.get_perf(app)['perf']
                   for app in self.workload])

   This analysis involves a large design space exploration. To accelerate the
   exhaustive search, this analysis also takes advantage of parallel execution
   to run fast on multicore machines.

   Finally, the analysis is plotted in
   :func:`~lumos.analyses.heterosys_example.HeterosysExample.plot`.

3. More examples.

   There are a lot of analyses in ``$LUMOS_HOME/lumos/analyses``, which can be
   used as examples of various functions the Lumos framework provides.
   Unfortunately, they were less documented at this moment.






Indices and tables
==================

* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`

