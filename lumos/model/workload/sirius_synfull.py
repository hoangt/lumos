#!/usr/bin/env python
""" Build fully synthetic kernels and applications. Kernels' characteristics
are derived from Sirius suite (assumed to be at sirius.xml at current directory)
"""
import random
from datetime import datetime
import argparse
import sys
import os

import numpy
from lxml import etree

from lumos.model.workload import load_kernels_and_apps

parser = argparse.ArgumentParser(
    prog="python -m lumos.model.workload.sirius_synfull",
    description=__doc__)
parser.add_argument('--napps',
                    type=int,
                    help='number of apps to generate',
                    required=True)
parser.add_argument('--nkernels',
                    type=int,
                    help='number of kernels to generate',
                    required=True)
parser.add_argument('--nkernels-in-app-mean',
                    type=int,
                    required=True,
                    help='the average number of kernels per-application')
parser.add_argument('-o',
                    '--output-file',
                    required=True,
                    help='output workload in XML file')
parser.add_argument('--non-kernel',
                    type=int,
                    help='non-kernel portion in permille, default: %(default)s',
                    default=1)
parser.add_argument(
    '--nkernels-in-app-std',
    type=int,
    default=0,
    help='the spread of number of kernels in an application, '
    'if 0, then all applications have the same number of kernels, default: %(default)s', )
parser.add_argument('--precision',
                    type=int,
                    help='precision of coverage, '
                    'e.g. 3 means 1e-3, default: %(default)s',
                    default=3)
parser.add_argument('--asic-perf-ratios',
                    default='5,10,20,40',
                    help='a list of comma-separated values '
                    'for ASIC performance ratio, default: %(default)s')
parser.add_argument('--coreonly-coverage',
                    default='random',
                    help='coverage of the coreonly kernel, default: %(default)s')
args = parser.parse_args()

if args.nkernels_in_app_std != 0:
    print('Non-zero nkernels-in-app-std not supported yet')
    sys.exit(1)

if args.nkernels_in_app_mean > args.nkernels:
    print('nkernels-in-app-mean is larger than nkernels')
    sys.exit(1)

sirius_original = os.path.join(os.path.dirname(__file__), 'sirius.xml')
origin_kernels, origina_apps = load_kernels_and_apps(sirius_original)

fpga_perfs = [_.get_kernel_param('fpga').perf for _ in origin_kernels.values()
              if _.name != "coreonly"]
fpga_perf_max = max(fpga_perfs)
fpga_perf_min = min(fpga_perfs)
kernel_perfs = numpy.linspace(fpga_perf_min, fpga_perf_max, args.nkernels)

_file_description_ = """
Workload generated by synapps_from_sirius.py

- The script reads kernel characteristics from {0};
- Number of kernels: {1};
- Number of applications: {2};
- Coverage precision: 1e-{3};
- Non-kernel coverage: {4}e-{3};
- ASIC performance ratios: {5};
- Coreonly coverage: {6};
- Generated at: {time:%H:%M:%S, %Y-%m-%d}
""".format(sirius_original,
           args.nkernels,
           args.napps,
           args.precision,
           args.non_kernel,
           args.asic_perf_ratios,
           args.coreonly_coverage,
           time=datetime.now())

asic_perf_ratios = [float(_) for _ in args.asic_perf_ratios.split(',')]

# copied from dnnasr in sirius.xml
core_perf_config_str = """
<core_perf_config>
  <cache_sz_l1_nom>65536</cache_sz_l1_nom>
  <cache_sz_l2_nom>18874368</cache_sz_l2_nom>
  <miss_l1>0.0842</miss_l1>
  <miss_l2>0.0734</miss_l2>
  <alpha_l1>5</alpha_l1>
  <alpha_l2>0.5</alpha_l2>
  <rm>0.129</rm>
  <cpi_exe>0.378</cpi_exe>
  <pf>0.952</pf>
</core_perf_config>
"""

# copied from sirius_synapp_nonkernel0.01.xml
coreonly_kernel_str = """
    <kernel name="coreonly">
      <core_perf_config>
        <cache_sz_l1_nom>65536</cache_sz_l1_nom>
        <cache_sz_l2_nom>18874368</cache_sz_l2_nom>
        <miss_l1>0.0158</miss_l1>
        <miss_l2>0.931</miss_l2>
        <alpha_l1>5</alpha_l1>
        <alpha_l2>0.5</alpha_l2>
        <rm>0.294</rm>
        <cpi_exe>0.55</cpi_exe>
        <pf>1</pf>
      </core_perf_config>
    </kernel>
"""

root = etree.Element('workload')
root.append(etree.Comment(_file_description_))

# parse kernel characteristics from sirius_original, then generate new kernels
# without this parser tweak, pretty print won't work
parser = etree.XMLParser(remove_blank_text=True)
kernel_pool = []
kernel_root = etree.SubElement(root, 'kernels')
kernel_root.append(etree.fromstring(coreonly_kernel_str, parser))
for i, perf in enumerate(kernel_perfs):
    kname = 'k_{}'.format(i)
    kernel_pool.append(kname)
    kernel = etree.SubElement(kernel_root, 'kernel', name=kname)
    acc_root = etree.SubElement(kernel, 'accelerator')
    etree.SubElement(acc_root, 'fpga', perf='{:.2f}'.format(perf))
    for asic_perf_ratio in asic_perf_ratios:
        etree.SubElement(acc_root,
                         'asic_{}x'.format(int(asic_perf_ratio)),
                         perf='{:.2f}'.format(perf * asic_perf_ratio))
    kernel.append(etree.fromstring(core_perf_config_str, parser))

app_root = etree.SubElement(root, 'apps', type='synthetic')

# args.precision = 3  # 1e-3
randrange_min = 0
if args.coreonly_coverage == 'random':
    randrange_max = 10 ** args.precision - args.non_kernel
else:
    randrange_max = 10 ** args.precision - args.non_kernel - int(
        args.coreonly_coverage)
for n in range(args.napps):
    kernels = random.sample(kernel_pool, args.nkernels_in_app_mean)
    if args.coreonly_coverage == 'random':
        kernels.append('coreonly')
        rand_indexes = sorted([random.randrange(randrange_min, randrange_max)
                               for _ in range(len(kernels) - 1)])
        rand_indexes.insert(0, 0)
        rand_indexes.append(randrange_max)
        coverage_list = [(rand_indexes[idx + 1] - rand_indexes[idx]) / 10
                         ** args.precision for idx in range(len(kernels))]
    else:
        rand_indexes = sorted([random.randrange(randrange_min, randrange_max)
                               for _ in range(len(kernels) - 1)])
        rand_indexes.insert(0, 0)
        rand_indexes.append(randrange_max)
        coverage_list = [(rand_indexes[idx + 1] - rand_indexes[idx]) / 10
                         ** args.precision for idx in range(len(kernels))]
        kernels.append('coreonly')
        coreonly_coverage = float(
            args.coreonly_coverage) / 10 ** args.precision
        coverage_list.append(coreonly_coverage)

    app = etree.SubElement(app_root, 'app', name='app_{0}'.format(n))
    kernel_config = etree.SubElement(app, 'kernel_config')
    for cov, k_ in zip(coverage_list, kernels):
        etree.SubElement(kernel_config,
                         'kernel',
                         name=k_,
                         cov='{0:.{width}f}'.format(cov,
                                                    width=args.precision))

tree = etree.ElementTree(root)
tree.write(args.output_file, pretty_print=True)
